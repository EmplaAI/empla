"""
empla.bdi.intentions - Intention Stack

BDI Intention System implementation:
- Manages employee intentions (BDI Intentions/Plans)
- Handles intention execution lifecycle
- Manages intention dependencies
- Prioritizes and schedules intentions
- Generates plans using LLM when no learned strategy exists
"""

import logging
from datetime import UTC, datetime, timedelta
from typing import TYPE_CHECKING, Any, Literal
from uuid import UUID

from pydantic import BaseModel, Field, field_validator
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from empla.models.employee import EmployeeIntention

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from empla.llm import LLMService
    from empla.models.belief import Belief
    from empla.models.employee import EmployeeGoal

# Allowed intention types (must match database constraint)
IntentionType = Literal["action", "tactic", "strategy"]


class PlanStep(BaseModel):
    """
    Single step in a generated plan.

    Example:
        >>> step = PlanStep(
        ...     action="research_competitors",
        ...     description="Research main competitors for context",
        ...     parameters={"query": "Acme Corp competitors", "max_results": 5},
        ...     expected_outcome="List of 5 main competitors with key info",
        ...     estimated_duration_minutes=15,
        ...     required_capabilities=["research", "web_search"]
        ... )
    """

    action: str = Field(..., description="Action to perform", min_length=1)
    description: str = Field(..., description="Why this step is needed", min_length=1)
    parameters: dict[str, Any] = Field(
        default_factory=dict, description="Action-specific parameters"
    )
    expected_outcome: str = Field(..., description="What should happen", min_length=1)
    estimated_duration_minutes: int | None = Field(
        default=None, ge=1, description="Estimated duration in minutes"
    )
    required_capabilities: list[str] = Field(
        default_factory=list, description="Capabilities needed for this step"
    )


class GeneratedIntention(BaseModel):
    """
    Single intention generated by LLM.

    Example:
        >>> intention = GeneratedIntention(
        ...     intention_type="action",
        ...     description="Research Acme Corp background",
        ...     priority=8,
        ...     plan={
        ...         "steps": [step1, step2, step3],
        ...         "expected_duration": "30_minutes"
        ...     },
        ...     reasoning="Need context before outreach",
        ...     estimated_duration_minutes=30,
        ...     dependencies=[],
        ...     required_capabilities=["research"]
        ... )
    """

    intention_type: IntentionType = Field(
        ..., description="Type of intention (action, tactic, strategy)"
    )
    description: str = Field(
        ..., description="Human-readable intention description", min_length=1, max_length=500
    )
    priority: int = Field(..., ge=1, le=10, description="Priority (1=lowest, 10=highest)")
    plan: dict[str, Any] = Field(
        ..., description="Structured plan with steps and expected outcomes"
    )
    reasoning: str = Field(..., description="Why this approach was chosen", min_length=1)
    estimated_duration_minutes: int | None = Field(
        default=None, ge=1, description="Estimated total duration in minutes"
    )
    dependencies: list[int] = Field(
        default_factory=list,
        description="Indexes of other intentions this depends on (0-based)",
    )
    required_capabilities: list[str] = Field(
        default_factory=list, description="Capabilities needed to execute this intention"
    )

    @field_validator("intention_type", mode="before")
    @classmethod
    def normalize_intention_type(cls, v: str | IntentionType) -> str:
        """Normalize intention_type to lowercase and validate."""
        if not isinstance(v, str):
            return v

        normalized = v.lower().strip()

        # Map common variants
        variant_map = {
            "task": "action",
            "step": "action",
            "approach": "tactic",
            "method": "tactic",
            "plan": "strategy",
            "campaign": "strategy",
        }
        normalized = variant_map.get(normalized, normalized)

        # Validate
        allowed: set[str] = {"action", "tactic", "strategy"}
        if normalized not in allowed:
            raise ValueError(
                f"Invalid intention_type '{v}'. Must be one of: {', '.join(sorted(allowed))}"
            )

        return normalized


class PlanGenerationResult(BaseModel):
    """
    Result of generating a plan for a goal using LLM.

    Example:
        >>> result = PlanGenerationResult(
        ...     intentions=[intention1, intention2, intention3],
        ...     strategy_summary="Multi-touch outreach campaign with research phase",
        ...     assumptions=["Customer has budget", "Decision maker accessible"],
        ...     risks=["May need multiple follow-ups", "Competitor timing"],
        ...     success_criteria=["Meeting booked", "Strong interest confirmed"]
        ... )
    """

    intentions: list[GeneratedIntention] = Field(
        default_factory=list, description="List of intentions to execute"
    )
    strategy_summary: str = Field(..., description="High-level strategy overview", min_length=1)
    assumptions: list[str] = Field(
        default_factory=list, description="Assumptions made in this plan"
    )
    risks: list[str] = Field(
        default_factory=list, description="Potential risks or challenges identified"
    )
    success_criteria: list[str] = Field(
        default_factory=list, description="How to measure success of this plan"
    )


class IntentionStack:
    """
    BDI Intention Stack (Plans).

    Manages an employee's intentions - the plans they commit to executing.
    Intentions are prioritized, can have dependencies, and track execution state.

    Example:
        >>> intention_stack = IntentionStack(session, employee_id, tenant_id)
        >>> intention = await intention_stack.add_intention(
        ...     goal_id=goal.id,
        ...     intention_type="action",
        ...     description="Send follow-up email to prospect",
        ...     plan={"type": "send_email", "to": "prospect@company.com", ...},
        ...     priority=8
        ... )
    """

    def __init__(
        self,
        session: AsyncSession,
        employee_id: UUID,
        tenant_id: UUID,
    ) -> None:
        """
        Initialize IntentionStack.

        Args:
            session: SQLAlchemy async session
            employee_id: Employee this intention stack belongs to
            tenant_id: Tenant ID for multi-tenancy
        """
        self.session = session
        self.employee_id = employee_id
        self.tenant_id = tenant_id

    async def add_intention(
        self,
        intention_type: str,
        description: str,
        plan: dict[str, Any],
        priority: int = 5,
        goal_id: UUID | None = None,
        context: dict[str, Any] | None = None,
        dependencies: list[UUID] | None = None,
    ) -> EmployeeIntention:
        """
        Add a new intention to the stack.

        Args:
            intention_type: Type of intention (action, tactic, strategy)
            description: Human-readable intention description
            plan: Structured plan (steps, resources, expected outcomes)
            priority: Priority (1=lowest, 10=highest)
            goal_id: Goal this intention serves (None for opportunistic intentions)
            context: Why this plan was chosen (rationale, alternatives considered)
            dependencies: Other intention UUIDs this depends on

        Returns:
            Created EmployeeIntention

        Example:
            >>> intention = await intention_stack.add_intention(
            ...     intention_type="action",
            ...     description="Research competitors for Acme Corp deal",
            ...     plan={
            ...         "steps": [
            ...             {"action": "search_web", "query": "Acme Corp competitors"},
            ...             {"action": "analyze_results", "max_competitors": 5},
            ...             {"action": "summarize_findings"}
            ...         ],
            ...         "expected_duration": "15_minutes",
            ...         "required_capabilities": ["research", "web_search"]
            ...     },
            ...     priority=7,
            ...     goal_id=goal.id
            ... )
        """
        intention = EmployeeIntention(
            tenant_id=self.tenant_id,
            employee_id=self.employee_id,
            goal_id=goal_id,
            intention_type=intention_type,
            description=description,
            plan=plan,
            status="planned",
            priority=priority,
            context=context or {},
            dependencies=dependencies or [],
        )

        self.session.add(intention)
        await self.session.flush()

        return intention

    async def get_intention(self, intention_id: UUID) -> EmployeeIntention | None:
        """
        Get a specific intention by ID.

        Args:
            intention_id: Intention UUID

        Returns:
            EmployeeIntention if found, None otherwise
        """
        result = await self.session.execute(
            select(EmployeeIntention).where(
                EmployeeIntention.id == intention_id,
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.deleted_at.is_(None),
            )
        )
        return result.scalar_one_or_none()

    async def get_planned_intentions(
        self,
        min_priority: int = 1,
    ) -> list[EmployeeIntention]:
        """
        Get all planned intentions (ready to execute).

        Args:
            min_priority: Minimum priority threshold (1-10)

        Returns:
            List of planned EmployeeIntentions, ordered by priority (highest first)
        """
        result = await self.session.execute(
            select(EmployeeIntention)
            .where(
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.status == "planned",
                EmployeeIntention.priority >= min_priority,
                EmployeeIntention.deleted_at.is_(None),
            )
            .order_by(EmployeeIntention.priority.desc(), EmployeeIntention.created_at.asc())
        )
        return list(result.scalars().all())

    async def get_intentions_for_goal(
        self,
        goal_id: UUID,
    ) -> list[EmployeeIntention]:
        """
        Get all intentions for a specific goal.

        Args:
            goal_id: Goal UUID

        Returns:
            List of EmployeeIntentions for the goal
        """
        result = await self.session.execute(
            select(EmployeeIntention)
            .where(
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.goal_id == goal_id,
                EmployeeIntention.deleted_at.is_(None),
            )
            .order_by(EmployeeIntention.priority.desc())
        )
        return list(result.scalars().all())

    async def get_next_intention(self) -> EmployeeIntention | None:
        """
        Get the next intention to execute.

        Selection criteria:
        1. Must be planned (not in_progress, completed, failed, or abandoned)
        2. Dependencies must be satisfied (all dependency intentions completed)
        3. Highest priority wins

        Returns:
            Next EmployeeIntention to execute, or None if none available
        """
        planned = await self.get_planned_intentions()

        for intention in planned:
            # Check if dependencies are satisfied
            if await self._are_dependencies_satisfied(intention):
                return intention

        return None

    async def _are_dependencies_satisfied(
        self,
        intention: EmployeeIntention,
    ) -> bool:
        """
        Check if all dependencies for an intention are satisfied.

        Args:
            intention: Intention to check

        Returns:
            True if all dependencies are completed, False otherwise
        """
        if not intention.dependencies:
            return True

        # Get all dependency intentions (excluding soft-deleted)
        result = await self.session.execute(
            select(EmployeeIntention).where(
                EmployeeIntention.id.in_(intention.dependencies),
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.deleted_at.is_(None),
            )
        )
        dependencies = list(result.scalars().all())

        # Verify all requested dependencies were found (not deleted)
        if len(dependencies) != len(intention.dependencies):
            return False  # Some dependencies missing or deleted

        # All dependencies must be completed
        return all(dep.status == "completed" for dep in dependencies)

    async def start_intention(
        self,
        intention_id: UUID,
    ) -> EmployeeIntention | None:
        """
        Mark an intention as in_progress.

        Verifies all dependencies are completed before allowing the intention to start.
        If dependencies are not satisfied, returns the intention unchanged.

        Args:
            intention_id: Intention UUID

        Returns:
            Updated EmployeeIntention if started, or unchanged intention if dependencies
            not satisfied, or None if not found

        Example:
            >>> # Create dependent intentions
            >>> dep1 = await stack.add_intention(...)
            >>> dep2 = await stack.add_intention(...)
            >>>
            >>> # Create intention with dependencies
            >>> intention = await stack.add_intention(
            ...     dependencies=[dep1.id, dep2.id],
            ...     ...
            ... )
            >>>
            >>> # Try to start before dependencies complete - returns unchanged
            >>> result = await stack.start_intention(intention.id)
            >>> assert result.status == "planned"
            >>>
            >>> # Complete dependencies
            >>> await stack.complete_intention(dep1.id)
            >>> await stack.complete_intention(dep2.id)
            >>>
            >>> # Now can start - returns updated
            >>> result = await stack.start_intention(intention.id)
            >>> assert result.status == "in_progress"
        """
        intention = await self.get_intention(intention_id)

        if not intention:
            return None

        if intention.status != "planned":
            # Already started or completed
            return intention

        # Verify all dependencies are satisfied before starting
        if not await self._are_dependencies_satisfied(intention):
            # Dependencies not satisfied - return intention unchanged
            return intention

        intention.status = "in_progress"
        intention.started_at = datetime.now(UTC)

        await self.session.flush()
        return intention

    async def complete_intention(
        self,
        intention_id: UUID,
        outcome: dict[str, Any] | None = None,
    ) -> EmployeeIntention | None:
        """
        Mark an intention as completed.

        Args:
            intention_id: Intention UUID
            outcome: Execution outcome (stored in context)

        Returns:
            Updated EmployeeIntention, or None if not found
        """
        intention = await self.get_intention(intention_id)

        if not intention:
            return None

        intention.status = "completed"
        intention.completed_at = datetime.now(UTC)

        if outcome:
            updated_context = dict(intention.context or {})
            updated_context["outcome"] = outcome
            intention.context = updated_context

        await self.session.flush()
        return intention

    async def fail_intention(
        self,
        intention_id: UUID,
        error: str,
        retry: bool = True,
    ) -> EmployeeIntention | None:
        """
        Mark an intention as failed.

        Args:
            intention_id: Intention UUID
            error: Error description
            retry: Whether to retry this intention

        Returns:
            Updated EmployeeIntention, or None if not found
        """
        intention = await self.get_intention(intention_id)

        if not intention:
            return None

        intention.status = "failed"
        intention.failed_at = datetime.now(UTC)
        updated_context = dict(intention.context or {})
        updated_context["error"] = error
        updated_context["retry"] = retry
        intention.context = updated_context

        await self.session.flush()
        return intention

    async def abandon_intention(
        self,
        intention_id: UUID,
        reason: str,
    ) -> EmployeeIntention | None:
        """
        Abandon an intention.

        Args:
            intention_id: Intention UUID
            reason: Reason for abandonment

        Returns:
            Updated EmployeeIntention, or None if not found
        """
        intention = await self.get_intention(intention_id)

        if not intention:
            return None

        intention.status = "abandoned"
        updated_context = dict(intention.context or {})
        updated_context["abandonment_reason"] = reason
        updated_context["abandoned_at"] = datetime.now(UTC).isoformat()
        intention.context = updated_context

        await self.session.flush()
        return intention

    async def update_intention_priority(
        self,
        intention_id: UUID,
        new_priority: int,
    ) -> EmployeeIntention | None:
        """
        Update intention priority.

        Args:
            intention_id: Intention UUID
            new_priority: New priority (1-10)

        Returns:
            Updated EmployeeIntention, or None if not found
        """
        intention = await self.get_intention(intention_id)

        if not intention:
            return None

        intention.priority = new_priority
        intention.updated_at = datetime.now(UTC)

        await self.session.flush()
        return intention

    async def get_in_progress_intentions(self) -> list[EmployeeIntention]:
        """
        Get all in-progress intentions.

        Returns:
            List of in-progress EmployeeIntentions
        """
        result = await self.session.execute(
            select(EmployeeIntention)
            .where(
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.status == "in_progress",
                EmployeeIntention.deleted_at.is_(None),
            )
            .order_by(EmployeeIntention.started_at.asc())
        )
        return list(result.scalars().all())

    async def get_failed_intentions(
        self,
        retryable_only: bool = True,
    ) -> list[EmployeeIntention]:
        """
        Get failed intentions.

        Args:
            retryable_only: Only return intentions marked for retry

        Returns:
            List of failed EmployeeIntentions
        """
        result = await self.session.execute(
            select(EmployeeIntention).where(
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.status == "failed",
                EmployeeIntention.deleted_at.is_(None),
            )
        )
        intentions = list(result.scalars().all())

        if retryable_only:
            intentions = [i for i in intentions if i.context.get("retry", False)]

        return intentions

    async def retry_intention(
        self,
        intention_id: UUID,
    ) -> EmployeeIntention | None:
        """
        Retry a failed intention.

        Args:
            intention_id: Intention UUID

        Returns:
            Updated EmployeeIntention, or None if not found
        """
        intention = await self.get_intention(intention_id)

        if not intention:
            return None

        if intention.status != "failed":
            return intention

        # Reset to planned state
        intention.status = "planned"
        intention.failed_at = None

        # Track retry count
        retry_count = intention.context.get("retry_count", 0)
        updated_context = dict(intention.context or {})
        updated_context["retry_count"] = retry_count + 1
        updated_context["last_retry_at"] = datetime.now(UTC).isoformat()
        intention.context = updated_context

        await self.session.flush()
        return intention

    async def clear_completed_intentions(
        self,
        older_than_days: int = 7,
    ) -> int:
        """
        Clear (soft delete) completed intentions older than N days.

        This prevents the intention stack from growing indefinitely.

        Args:
            older_than_days: Delete intentions completed more than N days ago

        Returns:
            Number of intentions cleared
        """
        now = datetime.now(UTC)
        cutoff = now - timedelta(days=older_than_days)

        result = await self.session.execute(
            select(EmployeeIntention).where(
                EmployeeIntention.employee_id == self.employee_id,
                EmployeeIntention.tenant_id == self.tenant_id,
                EmployeeIntention.status == "completed",
                EmployeeIntention.completed_at < cutoff,
                EmployeeIntention.deleted_at.is_(None),
            )
        )
        intentions = list(result.scalars().all())

        for intention in intentions:
            intention.deleted_at = now

        await self.session.flush()
        return len(intentions)

    async def generate_plan_for_goal(
        self,
        goal: "EmployeeGoal",
        beliefs: list["Belief"],
        llm_service: "LLMService",
        capabilities: list[str] | None = None,
    ) -> list[EmployeeIntention]:
        """
        Generate a plan to achieve a goal using LLM.

        This uses the LLM to create a structured plan when no learned strategy exists.
        The LLM analyzes the goal, current beliefs, and available capabilities to
        generate a sequence of intentions (action plans) that work together to
        achieve the goal.

        Args:
            goal: The goal to achieve
            beliefs: Current beliefs about the world (context for planning)
            llm_service: LLM service for plan generation
            capabilities: Available capabilities (None = use all employee capabilities)

        Returns:
            List of EmployeeIntentions that were created (in execution order)

        Example:
            >>> from empla.llm import LLMService, LLMConfig
            >>> llm_service = LLMService(LLMConfig(...))
            >>>
            >>> # Get goal and relevant beliefs
            >>> goal = await goals.get_goal(goal_id)
            >>> beliefs = await belief_system.get_all_beliefs(min_confidence=0.6)
            >>>
            >>> # Generate plan
            >>> intentions = await intention_stack.generate_plan_for_goal(
            ...     goal=goal,
            ...     beliefs=beliefs,
            ...     llm_service=llm_service,
            ...     capabilities=["email", "research", "calendar"]
            ... )
            >>> # Might generate:
            >>> # 1. Research account background
            >>> # 2. Craft personalized outreach email
            >>> # 3. Send email and schedule follow-up

        Note:
            This method is typically called from the proactive loop's strategic
            planning phase when the employee needs to figure out HOW to achieve a goal
            and there's no learned strategy in procedural memory.
        """
        # Build comprehensive system prompt
        system_prompt = """You are an AI assistant helping a digital employee generate an action plan to achieve a goal.

Your task: Analyze the goal, current beliefs (context), and available capabilities, then generate a structured plan with multiple intentions.

Guidelines:
1. Break down the goal into concrete, executable intentions
2. Each intention should be actionable with clear steps
3. Consider dependencies (some intentions must complete before others start)
4. Prioritize intentions based on criticality and urgency
5. Be realistic about time estimates
6. Only use capabilities the employee actually has
7. Provide clear reasoning for each intention

Intention types:
- action: Single concrete task (e.g., "Send follow-up email")
- tactic: Multi-step approach (e.g., "Research and qualify lead")
- strategy: High-level plan (e.g., "Launch outbound campaign")

Plan structure:
- Each intention should have detailed steps
- Steps should specify actions, parameters, expected outcomes
- Dependencies use 0-based indexes (intention 0, 1, 2, etc.)
- Include assumptions, risks, and success criteria for the overall plan

Examples:
- Goal: "Close deal with Acme Corp"
  Plan: 1) Research competitors (action), 2) Prepare proposal (tactic), 3) Send proposal (action)
  Dependencies: 2 depends on 1, 3 depends on 2

- Goal: "Build pipeline to 3x coverage"
  Plan: 1) Identify target accounts (tactic), 2) Launch outreach campaign (strategy)
  Dependencies: 2 depends on 1
"""

        # Format beliefs for prompt
        beliefs_text = self._format_beliefs_for_prompt(beliefs)

        # Format capabilities
        capabilities_list = capabilities or []
        capabilities_text = (
            ", ".join(capabilities_list) if capabilities_list else "No specific capabilities listed"
        )

        user_prompt = f"""Goal Type: {goal.goal_type}
Goal Description: {goal.description}
Goal Priority: {goal.priority}/10
Target Metrics: {goal.target}
Current Progress: {goal.current_progress}

Current Beliefs (Context):
{beliefs_text}

Available Capabilities: {capabilities_text}

Generate a detailed plan to achieve this goal. Include multiple intentions with clear steps, dependencies, and reasoning.
"""

        # Use LLM to generate plan with error handling
        try:
            _, plan_result = await llm_service.generate_structured(
                prompt=user_prompt,
                system=system_prompt,
                response_format=PlanGenerationResult,
                temperature=0.4,  # Balance creativity and consistency
            )
        except Exception as e:
            logger.error(
                f"LLM plan generation failed for goal {goal.id}: {e}",
                exc_info=True,
                extra={
                    "goal_id": str(goal.id),
                    "goal_description": goal.description,
                    "employee_id": str(self.employee_id),
                },
            )
            # Return empty list on LLM failure to prevent planning cycle crash
            return []

        # Create intentions from generated plan
        created_intentions: list[EmployeeIntention] = []
        intention_id_map: dict[int, UUID] = {}  # Map from index to actual UUID

        for idx, generated in enumerate(plan_result.intentions):
            # Resolve dependencies (convert indexes to actual UUIDs)
            resolved_deps: list[UUID] = []
            for dep_idx in generated.dependencies:
                if dep_idx in intention_id_map:
                    resolved_deps.append(intention_id_map[dep_idx])
                else:
                    logger.warning(
                        f"Intention {idx} has invalid dependency index {dep_idx}, skipping",
                        extra={
                            "goal_id": str(goal.id),
                            "intention_index": idx,
                            "dependency_index": dep_idx,
                        },
                    )

            # Build context with reasoning and metadata
            context = {
                "reasoning": generated.reasoning,
                "strategy_summary": plan_result.strategy_summary,
                "estimated_duration_minutes": generated.estimated_duration_minutes,
                "required_capabilities": generated.required_capabilities,
                "generation_metadata": {
                    "generated_at": datetime.now(UTC).isoformat(),
                    "assumptions": plan_result.assumptions,
                    "risks": plan_result.risks,
                    "success_criteria": plan_result.success_criteria,
                },
            }

            # Create intention using existing add_intention method
            intention = await self.add_intention(
                goal_id=goal.id,
                intention_type=generated.intention_type,
                description=generated.description,
                plan=generated.plan,
                priority=generated.priority,
                context=context,
                dependencies=resolved_deps,
            )

            created_intentions.append(intention)
            intention_id_map[idx] = intention.id

        logger.info(
            f"Generated {len(created_intentions)} intentions for goal {goal.id}",
            extra={
                "goal_id": str(goal.id),
                "goal_description": goal.description,
                "intentions_count": len(created_intentions),
                "strategy_summary": plan_result.strategy_summary,
            },
        )

        return created_intentions

    def _format_beliefs_for_prompt(self, beliefs: list["Belief"]) -> str:
        """
        Format beliefs for LLM prompt.

        Args:
            beliefs: List of beliefs to format

        Returns:
            Formatted string representation of beliefs
        """
        if not beliefs:
            return "No current beliefs"

        lines = []
        for belief in beliefs[:20]:  # Limit to top 20 beliefs to avoid token overflow
            # Format: Subject → Predicate: Object (confidence)
            obj_str = str(belief.object)
            if len(obj_str) > 100:
                obj_str = obj_str[:97] + "..."
            lines.append(
                f"- {belief.subject} → {belief.predicate}: {obj_str} "
                f"(confidence: {belief.confidence:.2f})"
            )

        if len(beliefs) > 20:
            lines.append(f"... and {len(beliefs) - 20} more beliefs")

        return "\n".join(lines)

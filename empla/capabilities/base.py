"""
Base Capability Abstraction

Defines the core interface and models for all capabilities.
"""

import logging
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any, TypeAlias
from uuid import UUID

from pydantic import BaseModel, Field

# Import unified Observation from core.loop.models and re-export for backward compatibility
from empla.core.loop.models import Observation

# Re-export Observation so imports from capabilities.base continue to work
__all__ = [
    "CAPABILITY_BROWSER",
    "CAPABILITY_CALENDAR",
    "CAPABILITY_COMPUTE",
    "CAPABILITY_COMPUTER_USE",
    "CAPABILITY_CRM",
    "CAPABILITY_DOCUMENT",
    "CAPABILITY_EMAIL",
    "CAPABILITY_MESSAGING",
    "CAPABILITY_VOICE",
    "CAPABILITY_WORKSPACE",
    "Action",
    "ActionResult",
    "BaseCapability",
    "CapabilityConfig",
    "CapabilityType",
    "Observation",
]

logger = logging.getLogger(__name__)

# CapabilityType is a plain string. Use the well-known constants below for
# discoverability, but any string is valid — new capabilities don't require
# code changes here.
CapabilityType: TypeAlias = str

# Well-known capability type constants
CAPABILITY_EMAIL: CapabilityType = "email"
CAPABILITY_CALENDAR: CapabilityType = "calendar"
CAPABILITY_MESSAGING: CapabilityType = "messaging"
CAPABILITY_BROWSER: CapabilityType = "browser"
CAPABILITY_DOCUMENT: CapabilityType = "document"
CAPABILITY_CRM: CapabilityType = "crm"
CAPABILITY_VOICE: CapabilityType = "voice"
CAPABILITY_COMPUTER_USE: CapabilityType = "computer_use"
CAPABILITY_WORKSPACE: CapabilityType = "workspace"
CAPABILITY_COMPUTE: CapabilityType = "compute"


class CapabilityConfig(BaseModel):
    """
    Base configuration for all capabilities.

    Each capability extends this with capability-specific configuration.
    """

    enabled: bool = True
    """Whether this capability is enabled"""

    rate_limit: int | None = None
    """Max operations per minute (None = unlimited)"""

    retry_policy: dict[str, Any] = Field(default={"max_retries": 3, "backoff": "exponential"})
    """Retry policy for failed operations"""

    timeout_seconds: int = 30
    """Operation timeout in seconds"""

    class Config:
        extra = "allow"  # Allow capability-specific config


class Action(BaseModel):
    """
    Action to be executed by a capability.

    Actions are generated by the BDI system during intention execution
    and passed to capabilities for execution.
    """

    capability: str
    """Which capability should execute this action"""

    operation: str
    """What operation to perform (capability-specific)"""

    parameters: dict[str, Any]
    """Operation parameters"""

    priority: int = Field(ge=1, le=10, default=5)
    """Action priority 1-10"""

    deadline: datetime | None = None
    """When this action must be completed by"""

    context: dict[str, Any] = Field(default_factory=dict)
    """Additional context for execution"""

    class Config:
        json_schema_extra = {
            "example": {
                "capability": "email",
                "operation": "send_email",
                "parameters": {
                    "to": ["recipient@example.com"],
                    "subject": "Response to your inquiry",
                    "body": "Thank you for reaching out...",
                },
                "priority": 7,
                "context": {"thread_id": "thread-123"},
            }
        }


class ActionResult(BaseModel):
    """
    Result of executing an action.

    Returned by capabilities after action execution.
    """

    success: bool
    """Whether the action succeeded"""

    output: Any | None = None
    """Action output (capability-specific)"""

    error: str | None = None
    """Error message if failed"""

    metadata: dict[str, Any] = Field(default_factory=dict)
    """Additional metadata (timing, cost, etc.)"""

    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "output": {"email_id": "456", "sent_at": "2025-11-12T10:35:00Z"},
                "error": None,
                "metadata": {"duration_ms": 234, "provider": "microsoft_graph"},
            }
        }


class BaseCapability(ABC):
    """
    Base class for all capabilities.

    A capability is a discrete unit of functionality that provides:
    1. **Perception** - observe environment for changes/events
    2. **Action** - execute specific operations with robust retry logic
    3. **State** - maintain capability-specific state

    Capabilities are:
    - **Tenant-scoped** - isolated per customer
    - **Employee-scoped** - per-employee configuration
    - **Observable** - comprehensive logging and metrics
    - **Testable** - mock implementations available
    - **Reliable** - automatic retry for transient failures, PII-safe error logging

    Example:
        class MyCapability(BaseCapability):

            @property
            def capability_type(self) -> str:
                return CAPABILITY_EMAIL

            async def initialize(self) -> None:
                # Set up connections, auth, etc.
                pass

            async def perceive(self) -> List[Observation]:
                # Check for new events
                return [...]

            async def _execute_action_impl(self, action: Action) -> ActionResult:
                # Capability-specific execution logic
                # This is called by execute_action() which handles retry/errors
                return ActionResult(success=True)
    """

    def __init__(self, tenant_id: UUID, employee_id: UUID, config: CapabilityConfig) -> None:
        """
        Initialize the capability instance with tenant, employee, and configuration context.

        Parameters:
            tenant_id (UUID): Identifier of the tenant that owns the capability.
            employee_id (UUID): Identifier of the employee associated with the capability.
            config (CapabilityConfig): Configuration values controlling capability behavior.
        """
        self.tenant_id = tenant_id
        self.employee_id = employee_id
        self.config = config
        self._initialized = False

        # Retry configuration from config.retry_policy
        self.max_retries = config.retry_policy.get("max_retries", 3)
        self.initial_backoff_ms = 100
        self.max_backoff_ms = 5000
        self.backoff_multiplier = float(config.retry_policy.get("backoff_multiplier", 2.0))

    @property
    @abstractmethod
    def capability_type(self) -> str:
        """
        Identify this capability's category.

        Returns:
            A string identifying this capability's category (e.g. CAPABILITY_EMAIL).
        """

    @abstractmethod
    async def initialize(self) -> None:
        """
        Prepare the capability for use for the assigned employee.

        Performs startup work such as establishing connections and authentication. Called once when the capability is enabled; implementations should set self._initialized = True on successful completion.

        Raises:
            Exception: If initialization fails.
        """

    @abstractmethod
    async def perceive(self) -> list[Observation]:
        """
        Detects new events, changes, or triggers from the capability's environment and produces corresponding observations.

        Implementations should perform a single perception pass and return any observations discovered. If an error occurs, implementations must not raise; they should log the error and return an empty list.

        Returns:
            List[Observation]: Observations discovered during this perception pass; an empty list if nothing new or on error.
        """

    async def execute_action(self, action: Action) -> ActionResult:
        """
        Execute action with retry logic, error handling, and performance tracking.

        This method NEVER raises exceptions - all errors are captured in ActionResult.
        Features:
        - Exponential backoff retry for transient failures
        - Error classification (transient vs permanent)
        - PII-safe logging (never logs action parameters)
        - Performance tracking (duration_ms, retry count)
        - Zero-exception guarantee

        Parameters:
            action (Action): The operation to perform.

        Returns:
            ActionResult: Always returns, never raises. Contains success/failure, output/error, timing.
        """
        import asyncio
        import random
        from time import time

        start_time = time()
        last_error = None

        # Execute with retry logic (ported from ToolExecutionEngine)
        for attempt in range(self.max_retries + 1):
            try:
                # Log attempt (PII-safe - no parameters logged)
                if attempt > 0:
                    logger.info(
                        f"Retrying {action.operation} (attempt {attempt + 1}/{self.max_retries + 1})",
                        extra={
                            "capability": str(self.capability_type),
                            "operation": action.operation,
                            "attempt": attempt + 1,
                        },
                    )

                # Call capability-specific implementation
                result = await self._execute_action_impl(action)

                # Success! Add performance metadata
                duration_ms = (time() - start_time) * 1000
                if not result.metadata:
                    result.metadata = {}
                result.metadata["duration_ms"] = duration_ms
                result.metadata["retries"] = attempt

                if result.success:
                    logger.info(
                        f"Action {action.operation} executed successfully",
                        extra={
                            "capability": str(self.capability_type),
                            "operation": action.operation,
                            "duration_ms": duration_ms,
                            "retries": attempt,
                        },
                    )

                return result

            except Exception as e:
                last_error = e

                # Log error (PII-safe)
                logger.warning(
                    f"Action {action.operation} failed: {e}",
                    exc_info=True,
                    extra={
                        "capability": str(self.capability_type),
                        "operation": action.operation,
                        "attempt": attempt + 1,
                        "error": str(e),
                    },
                )

                # Check if we should retry
                if not self._should_retry(e) or attempt >= self.max_retries:
                    break

                # Exponential backoff with jitter (ported from ToolExecutionEngine)
                backoff_ms = min(
                    self.initial_backoff_ms * (self.backoff_multiplier**attempt),
                    self.max_backoff_ms,
                )
                # Add ±25% jitter to avoid thundering herd
                jitter = backoff_ms * 0.25 * (2 * random.random() - 1)
                backoff_ms += jitter

                await asyncio.sleep(backoff_ms / 1000)

        # All retries exhausted
        duration_ms = (time() - start_time) * 1000
        error_msg = f"{type(last_error).__name__}: {last_error}" if last_error else "Unknown error"

        logger.error(
            f"Action {action.operation} failed after {attempt + 1} attempts",
            extra={
                "capability": str(self.capability_type),
                "operation": action.operation,
                "duration_ms": duration_ms,
                "retries": attempt,
                "error": error_msg,
            },
        )

        return ActionResult(
            success=False,
            error=error_msg,
            metadata={"duration_ms": duration_ms, "retries": attempt},
        )

    @abstractmethod
    async def _execute_action_impl(self, action: Action) -> ActionResult:
        """
        Capability-specific action execution implementation.

        This is called by execute_action() which handles retry logic and error handling.
        Subclasses implement this method with their specific action execution logic.

        This method CAN raise exceptions - they will be caught by execute_action().

        Parameters:
            action (Action): The operation to perform.

        Returns:
            ActionResult: Outcome of execution. Can raise exceptions on failure.
        """

    def _should_retry(self, error: Exception) -> bool:
        """
        Determine if error is retryable (ported from ToolExecutionEngine).

        Transient errors (network, rate limit, timeout) should be retried.
        Permanent errors (auth, validation, not found) should not.

        Args:
            error: Exception that occurred

        Returns:
            True if should retry, False otherwise
        """
        error_str = str(error).lower()

        # Transient errors - should retry
        transient_indicators = [
            "timeout",
            "rate limit",
            "too many requests",
            "connection",
            "network",
            "temporary",
            "503",  # Service Unavailable
            "429",  # Too Many Requests
        ]

        for indicator in transient_indicators:
            if indicator in error_str:
                return True

        # Permanent errors - should NOT retry
        permanent_indicators = [
            "auth",
            "unauthorized",
            "forbidden",
            "not found",
            "invalid",
            "validation",
            "400",  # Bad Request
            "401",  # Unauthorized
            "403",  # Forbidden
            "404",  # Not Found
        ]

        for indicator in permanent_indicators:
            if indicator in error_str:
                return False

        # Unknown error type - don't retry (conservative approach)
        # Let employee decide whether to retry at higher level
        return False

    async def shutdown(self) -> None:
        """
        Perform an orderly shutdown of the capability, releasing resources and flushing any in-memory state.

        Called when the capability is disabled or the associated employee is deactivated. Subclasses should override to implement concrete cleanup; the base implementation is a no-op.
        """

    def is_healthy(self) -> bool:
        """
        Indicates whether the capability has completed initialization successfully.

        Returns:
            `true` if initialization completed successfully, `false` otherwise.
        """
        return self._initialized

    def __repr__(self) -> str:
        """
        Return a concise string representation of the capability instance.

        Returns:
            str: A string containing the class name, `capability_type`, `employee_id`, and whether the instance is initialized.
        """
        return (
            f"{self.__class__.__name__}("
            f"type={self.capability_type}, "
            f"employee={self.employee_id}, "
            f"initialized={self._initialized})"
        )
